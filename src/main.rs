#![warn(
    clippy::all,
    clippy::restriction,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::missing_docs_in_private_items,
    clippy::implicit_return,
    clippy::filter_map
)]
#![feature(proc_macro_hygiene, decl_macro)]

use id3;
use rocket::{get, response, routes, State};
use rss;
use std::fs;
use std::path::Path;
use std::rc::Rc;

#[derive(Debug)]
enum Error {
    IOError(std::io::Error),
}

struct PodcastState(Vec<PodData>);

impl From<std::io::Error> for Error {
    fn from(e: std::io::Error) -> Self {
        Error::IOError(e)
    }
}

#[derive(Debug)]
struct PodData {
    artist: Option<String>,
    title: Option<String>,
}

fn mkfeed(pods: &[PodData]) -> Result<rss::Channel, String> {
    rss::ChannelBuilder::default()
        .title("PodServe Feed")
        .description("An RSS feed generated by PodServe.")
        .items(
            pods.iter()
                .map(mkitem)
                .filter_map(Result::ok)
                .collect::<Vec<_>>(),
        )
        .build()
}

fn mkitem(pd: &PodData) -> Result<rss::Item, String> {
    let title = pd
        .title
        .clone()
        .ok_or_else(|| "Title not set".to_string())?;
    rss::ItemBuilder::default().title(title).build()
}

#[get("/")]
fn index(podcasts: State<PodcastState>) -> Result<response::content::Xml<String>, String> {
    Ok(response::content::Xml(mkfeed(&podcasts.0)?.to_string()))
}

fn read_podcast_dir<P: AsRef<Path>>(path: P) -> Result<Vec<PodData>, std::io::Error> {
    Ok(fs::read_dir(path)?
        .filter_map(Result::ok)
        .map(|p| p.path())
        .map(id3::Tag::read_from_path)
        .filter_map(Result::ok)
        .map(|id| PodData {
            artist: id.artist().map(ToOwned::to_owned),
            title: id.title().map(ToOwned::to_owned),
        })
        .collect::<Vec<_>>())
}

fn rocket() -> Result<rocket::Rocket, std::io::Error> {
    let podcasts = PodcastState(read_podcast_dir("podcasts")?);

    Ok(rocket::ignite().mount("/", routes![index]).manage(podcasts))
}

fn main() -> Result<(), std::io::Error> {
    rocket()?.launch();
    Ok(())
}
