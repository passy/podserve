#![warn(
    clippy::all,
    clippy::restriction,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::missing_docs_in_private_items,
    clippy::implicit_return,
    clippy::filter_map
)]
#![feature(proc_macro_hygiene, decl_macro)]

use id3;
use rocket::{get, response, routes, State};
use rocket_contrib::serve::StaticFiles;
use rss;
use std::fs;
use std::path::Path;

#[derive(Debug)]
enum Error {
    IOError(std::io::Error),
}

struct PodcastState(Vec<PodData>);

impl From<std::io::Error> for Error {
    fn from(e: std::io::Error) -> Self {
        Error::IOError(e)
    }
}

#[derive(Debug)]
struct PodData {
    artist: Option<String>,
    title: Option<String>,
    filename: String,
}

fn mkfeed(pods: &[PodData]) -> Result<rss::Channel, String> {
    rss::ChannelBuilder::default()
        .title("PodServe Feed")
        .description("An RSS feed generated by PodServe.")
        .items(
            pods.iter()
                .map(mkitem)
                .filter_map(Result::ok)
                .collect::<Vec<_>>(),
        )
        .build()
}

fn mkitem(pd: &PodData) -> Result<rss::Item, String> {
    rss::ItemBuilder::default()
        .title(pd.title.clone())
        .guid(
            rss::GuidBuilder::default()
                .value(pd.filename.clone())
                .build()?,
        )
        .build()
}

#[get("/")]
fn index(podcasts: State<PodcastState>) -> Result<response::content::Xml<String>, String> {
    Ok(response::content::Xml(mkfeed(&podcasts.0)?.to_string()))
}

fn read_podcast_dir<P: AsRef<Path>>(path: P) -> Result<Vec<PodData>, std::io::Error> {
    Ok(fs::read_dir(path)?
        .filter_map(Result::ok)
        .map(|p| p.path())
        .filter_map(|p| id3::Tag::read_from_path(&p).map(|t| (p, t)).ok())
        .map(|(path, tag): (std::path::PathBuf, id3::Tag)| PodData {
            artist: tag.artist().map(ToOwned::to_owned),
            title: tag.title().map(ToOwned::to_owned),
            filename: path.file_name().and_then(|s| s.to_str()).expect("Valid filename").to_string(),
        })
        .collect::<Vec<_>>())
}

fn rocket() -> Result<rocket::Rocket, std::io::Error> {
    let podcasts = PodcastState(read_podcast_dir("podcasts")?);

    Ok(
        rocket::ignite()
            .manage(podcasts)
            .mount("/", routes![index])
            // TODO: Make this configurable.
            .mount("/podcasts", StaticFiles::from(concat!(env!("CARGO_MANIFEST_DIR"), "/podcasts")))
        )
}

fn main() -> Result<(), std::io::Error> {
    rocket()?.launch();
    Ok(())
}
